---
layout: post
title:  "TCP建立连接后，保活"
date:  2016-05-20
categories: NetProtocol
---

TCP建立连接，连接保活

---


- 目录
{:toc}

### 简介

- TCP连接、释放过程

> 当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手

- TCP连接释放缺点

> 1. 优点：保证了通信的可靠性
> 2. 缺点：连接的建立都是需要消耗资源和时间

#### 短连接/长连接

- HTTP有Keepalive功能，TCP也有Keepalive功能，虽然都叫Keepalive，但是它们的目的却是不一样的。

> 1.短连接：建立一条连接，传输一个请求，马上关闭连接。
> 2.长连接：建立一条连接，传输一个请求，过会儿，又传输若干个请求，最后再关闭连接。
> 3.长连接的好处是显而易见的，多个请求可以复用一条连接，省去连接建立和释放的时间开销和系统调用，但也意味着服务器的一部分资源会被长时间占用着。

- HTTP的Keepalive

> 目的在于延长连接的时间，以便在同一条连接中传输多个HTTP请求。HTTP服务器一般会提供Keepalive Timeout参数，用来决定连接保持多久，什么时候关闭连接。当连接使用了Keepalive功能时，对于客户端发送过来的一个请求，服务器端会发送一个响应，然后开始计时，如果经过Timeout时间后，客户端没有再发送请求过来，服务器端就把连接关了，不再保持连接了。

- TCP的Keepalive

> 目的:在于看看对方有没有发生异常，如果有异常就及时关闭连接。当传输双方不主动关闭连接时，就算双方没有交换任何数据，连接也是一直有效的。


#### TCP保活方式

> 1. 1.TCP协议自身的保活定时器实现心跳
> 2. 2.通讯双方通过自定义协议实现心跳包来保活
> 3. 3.第三方应用来进行保活

### TCP保活

> 正常情况下，只要连接建立后，就会一直保持着,`不会主动断开`。但有时有一些防火墙之类的软件会自动检查主机的网络连接状况，比如说如果发现某个连接在几分钟之内都没有数据通讯，则会关闭这个连接。有时客户端与服务器需要实时的检测连接状态，就是需要知道对方是否还在线，如果对方不在线了，需要做相应的处理，这是就需要通过发送心跳包的方法监测链路的状态。


- 导致 TCP 连接断连的因素

> 理想状态下，一个 TCP 连接可以被长期保持。然而，在实际应用中，客户端或服务器端上维持的一个看似正常的 TCP 连接可能已经断连。

> TCP 连接主要受到两个方面的影响而导致断连：网络中间节点和客户端 / 服务器节点参与通信的两方节点。

> 1. 1.在实际网络应用中，两个主机之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等。因此，两个主机之间 TCP 连接的保持同样会受到中间节点的影响，尤其是会受到防火墙（软件或硬件防火墙）的限制。防火墙是一种装置，有多种不同的实现方式（软件实现、硬件设备实现或是软硬件相结合实现），它需要依据一系列规则对进出的信息流进行扫描，并允许安全（符合规则）的信息交互、阻止不安全（违反规则）的信息交互。防火墙的工作特性决定了要维护一个网络连接就需要耗费较多的资源，并且企业防火墙常常位于企业网络的出入口，长时间维护非活跃的 TCP 连接必将导致网络性能的下降。因此，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 TCP 连接断连。类似的，如果中间节点异常导致来自客户端关闭连接的请求无法传递到服务器端，也将导致服务器端的相应连接发生断连。
> 2. 2.另一方面，对于一个 TCP 连接两端的主机而言，创建 TCP 连接需要耗费一定的系统资源。如果不再使用某个连接，那么我们总是希望进行通信的两个主机能够主动关闭相应的连接，以便释放所占用的系统资源。然而，如果由于客户端出现异常 ( 例如崩溃或异常重启 ) 而导致连接未能正常关闭，这将导致服务器端的连接断连
> 3. 3.无论是客户端节点或是服务器端节点，断连的 TCP 连接已经不能传递任何信息，因此，维护大量断连的 TCP 连接将导致系统资源的浪费。这种系统资源的浪费可能并不会对客户端节点带来太大问题；然而，对于服务器主机而言，这可能会导致系统资源（尤指内存资源和 socket 资源）被耗尽而拒绝为新的用户请求提供服务。因此在实际应用中，服务器端需要采取相应的方法来探测 TCP 连接是否已经断连。

#### 保活定时器

- 功能：许多时候一个服务器希望知道客户主机是否崩溃并关机或崩溃又重新启动，保活定时器就提供这个功能

> 使用场景：一个说明现在需要使用保活功能的常见例子是当个人计算机用户使用TCP/IP向一个使用Telnet的主机注册时。如果在一天结束时，他们仅仅关闭了电源而没有注销，那么便会留下一个半开放的连接。通过一个半开放连接发送数据会导致返回一个复位，但那是在来自正在发送数据的客户端。如果客户已经消失了，使得在服务器上留下一个半开放连接，而服务器又在等待来自客户的数据，则服务器将永远等待下去。保活功能就是试图在服务器端检测到这种半开放的连接。

> 如果一个连接在两个小时之内没有任何动作，则服务器向客户发送探查报文。客户必须处于以下4中状态: 

> 1. 1)客户机依然正常运行，并从服务器可达。客户TCP响应正常，两小时内保活定时器复位。如果两小时内有数据交换，则在数据交换后的未来2小时再复位 
> 2. 2)客户机已经奔溃，并且关闭或正在重新启动，客户TCP没有响应。服务器收不到探查的响应，然后每隔75秒发送探查报文，总共发送10个，如果服务器没有收到一个响应，认为客户端已经关闭并终止连接 
> 3. 3)客户主机崩溃并已经重新启动，。这是服务器收到对其保活探查的响应，但是这个响应是一个复位，服务器终止连接 
> 4. 4)客户主机正常运行，但是从服务不可达，等同情况2

- 保活定时器缺陷：在连接两个端系统的网络出现临时故障的时候，保活选项会引起一个实际上很好的连接终止。例如，如果在一个中间路由器崩溃并重新启动时发送保活探查，T P会认为客户的主机已经崩溃，而实际上所发生的并非如此。

### 探测TCP断连

> 探测 TCP 连接是否断连或是工作正常的原理比较简单：定期向连接的远程通信节点发送一定格式的信息并等待远程通信节点的反馈，如果在规定时间内收到来自远程节点的正确的反馈信息，那么该连接就是正常的，否则该连接已经断连。依据该原理

#### 探测方法介绍

- 1.应用程序的自我探测 

> 应用程序本身附带探测其自身建立的 TCP 连接的功能。这种方法具有极大的灵活性，可以依据应用本身的特点选择相应的探测机制和功能实现。然而，实际应用中，大部分应用程序均没有附带自我探测的功能。

- 2.第三方应用程序的探测 

> 此种方法就是在服务节点上安装相应的第三方应用程序来探测该节点上所有的 TCP 连接是否正常或是已经断连。该方法最大的不足就是需要所有支持探测的客户端能够识别来自该探测应用的数据报文，因此，实际应用中比较少见。

- 3.TCP 协议层的保活探测 

> 最常用的探测方法就是采用 TCP 协议层提供的保活探测功能即 TCP 连接保活定时器。尽管该功能并不是 RFC 规范的一部分，但是几乎所有的类 Unix 系统均实现了该功能，所以使得该探测方法被广泛使用。

### 长连接与短连接

#### TCP短连接

> 我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作

- 短连接的优

> 管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段

#### TCP长连接

> 接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

- 长连接缺点：服务器维持连接状态，而不知道客户端是否宕机/消失

> 保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。

### WIN32(TCP保活)

> 在默认的情况下，TCP连接是没有保活的心跳的。这就是说，当一个TCP的socket，客户端与服务端谁也不发送数据，会一直保持着连接。这其中如果有一方异常掉线，另一端永远也不可能知道。这对于一些服务型的程序来说，将是灾难性的后果。

> - 所以，必须对创建的socket，启用保活心跳，即Keepalive选项。

- 选择保活定时器

> 下具体是用TCP协议自身的保活定时器实现心跳，还是通讯双方通过自定义协议实现心跳包来保活，还是通过第三方应用来进行保活，要取决于你的项目需求，网络负荷以及那种实现起来更便捷等多方面的因素，根据自身情况来使用。

### TCP四种定时器

> 1.重传计时器：Retransmission Timer
> 2.坚持计时器：Persistent Timer
> 3.保活计时器：Keeplive Timer
> 4.时间等待计时器：Time_Wait Timer。

#### 重传计时器

> 重传定时器(Retransmission Timer)：为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间。当TCP发送报文段时，就创建这个特定报文段的重传计时器，可能发生两种情况：若在计时器超时之前收到对报文段的确认，则撤销计时器;若在收到对特定报文段的确认之前计时器超时，则重传该报文，并把计时器复位;重传时间=2*RTT;

> RTT的值应该动态计算。
> 常用的公式是：RTT=previous RTT*i + (1-i)*current RTT。i的值通常取90%，即新的RTT是以前的RTT值的90%加上当前RTT值的10%.
> Karn算法：对重传报文，在计算新的RTT时，不考虑重传报文的RTT。因为无法推理出：发送端所收到的确认是对上一次报文段的确认还是对重传报文段的确认。干脆不计入。

> TCP在发送一份数据后，启动重传定时器，在经过若干时间后如果没有收到ACK，则重传该数据，这个时间间隔通常如下:1s, 3s, 6s, 12s, 24, 48s, 和多个64s。这个指数关系被称为指数退避。TCP会一直尝试重传该数据，在9分钟以后放弃。

#### 坚持计时器

- 作用: 专门为对付零窗口通知而设立的

> 假定有如下情况：接收方接收到一定量的数据，发现本地缓存满了，于是发送一个窗口大小为0的ACK给发送方，发送方在接收到该ACK后停止发送。一段时间后，接收方有空余的窗口，于是发送一个窗口大小非0的ACK以更新窗口，不幸的是该ACK丢失了，于是整个连接被停止。坚持定时器正是为了解决这个问题，它在接收到一个窗口大小为0的ACK以后，启动一个定时器，定时去查询是否窗口已经更新（同样采用指针退避）。

#### 保活定时器

- 功能：可检测到一个空闲连接的另一端何时崩溃或重启

#### 时间等待计时器

> 时间等待计时器:Time_Wait Timer在连接终止期使用，当TCP关闭连接时，并不认为这个连接就真正关闭了，在时间等待期间，连接还处于一种中间过度状态。这样就可以时重复的fin报文段在到达终点后被丢弃，这个计时器的值通常设置为一格报文段寿命期望值的两倍。

> 2MSL定时器测量一个连接处于TIME_WAIT状态的时间:2MSL时间是为了让TCP有时间发送最后一个ACK,防止该ACK丢失