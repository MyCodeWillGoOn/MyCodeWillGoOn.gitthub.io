---
layout: post
title:  "动态规划之01背包问题"
date:  2016-05-21
categories: Algorithm
---

动态规划之01背包问题

---

- 目录
{:toc}

### 一、基本01背包问题描述

> 1. **已知:** 有一个容量为V的背包和N件物品，第i件物品的重量是weight[i]，收益是cost[i]。
> 2. **限制:** 每种物品只有一件，可以选择放或者不放
> 3. **问题:** 在不超过背包容量的情况下，最多能获得多少价值或收益
> 4. **相似问题:** 在恰好装满背包的情况下，最多能获得多少价值或收益

> *这里，我们先讨论在不超过背包容量的情况下，最多能获得多少价值或收益。*

- 基本思路

> **01背包的特点:** 每种物品只有一件，可以选择放或者不放

#### 分析

- 考虑我们的子问题，将前i件物品放到容量为v的背包中，若我们只考虑第i件物品时，它有两种选择，放或者不放。

> 1）如果第i件物品不放入背包中，那么问题就转换为：将前i - 1件物品放到容量为v的背包中，带来的收益`f[i - 1][v]`


> 2）如果第i件物品能放入背包中，那么问题就转换为：将前i - 1件物品放到容量为v - weight[i]的背包中，带来的收益`f[i - 1][v - weight[i]] + cost[i]`

```java
	for (int i = 1;i <= N;i++) //枚举物品  
	    {  
	        for (int j = 0;j <= V;j++) //枚举背包容量  
	        {  
	            f[i][j] = f[i - 1][j];  
	            if (j >= weight[i])  
	            {  
	                f[i][j] = Max(f[i - 1][j],f[i - 1][j - weight[i]] + value[i]);  
	            }  
	        }  
	    }  

```

- 效率分析

> 此算法的时间复杂度为O(N*V)，空间复杂度也为O(N*V)。其中，N 表示物品个数，V 表示背包容量这里，时间复杂度不可以在优化了，但是空间复杂度可以继续优化到O(V)

- 优化空间复杂度

> 我们可以看到，要想得到`f[i][v]`，我们需要知道 `f[i-1][v]`和`f[i-1][v-weight[i]]`，由于我们使用二维数组保存中间状态，所以可以直接取出这两个状态。


> 当我们使用一维数组存储状态时，f[v]表示，在执行i次循环后(此时已经处理i个物品)，前i个物体放到容量v时的最大价值，即之前的`f[i][v]`。与二维相比较，它把第一维隐去了，但是二者表达的含义还是相同的，只不过针对不同的i，f[v]一直在重复使用，所以，也会出现第i次循环可能会覆盖第i-1次循环的结果。


> 为了求f[v],我们需要知道，前i - 1个物品放到容量v的背包中带来的收益，即之前的`f[i - 1][v]`和前i-1件物品放到容量为v-weight[i]的背包中带来的收益，即之前的`f[i-1][v-weight[i]]+cost[i]`。

- **`难点：`** 由于我们只使用一维数组存储，则在求这两个子问题时就没有直接取出那么方便了，因为第i次循环可能会覆盖第i - 1次循环的结果。

- 现在我们来求这两个值。

> 1）前i-1个物品放到容量v的背包中带来的收益，即之前的`f[i - 1][v]` ：
> 由于，在执行在i次循环时，f[v]存储的是前i个物体放到容量v时的最大价值，在求前i个物体放到容量v时的最大价值(即之前的`f[i][v]`)时，我们是正在执行第i次循环，f[v]的值还是在第i-1次循环时存下的值，在此时取出的f[v]就是前i-1个物体放到容量v时的最大价值，即`f[i-1][v]`。


> 2）前i - 1件物品放到容量为v - weight[i]的背包中带来的收益，即之前的`f[i - 1][v - weight[i]] + cost[i]`


> 由于，在执行第i次循环前，f[0 ~ V]中保存的是第i - 1次循环的结果，即是前i - 1个物体分别放到容量0 ~ V时的最大价值，即`f[i - 1][0 ~ V]`。则，在执行第i次循环前，f 数组中v- weight[i]的位置存储就是我们要找的 前i - 1件物品放到容量为v - weight[i]的背包中带来的收益 (即之前的`f[i - 1][v - weight[i]]`)，这里假设物品是从数组下标1开始存储的。

- 逆序枚举容量的原因

> 注意一点，我们是由第i-1次循环的两个状态推出 第i个状态的，而且v>v-weight[i]，则对于第i次循环，背包容量只有当V..0循环时，才会先处理背包容量为v的状况，后处理背包容量为v-weight[i] 的情况。
> 具体来说，由于在执行v时，还没执行到v - weight[i]的，因此，`f[v - weight[i]]`保存的还是第i-1次循环的结果。即在执行第i次循环且背包容量为v时，此时的f[v]存储的是 `f[i-1][v]`，此时`f[v-weight[i]]`存储的是`f[i-1][v-weight[i]]`。


> 相反，如果在执行第 i 次循环时，背包容量按照0..V的顺序遍历一遍，来检测第 i 件物品是否能放。此时在执行第i次循环且背包容量为v时，此时的f[v]存储的是`f[i - 1][v]`，但是，此时`f[v-weight[i]]`存储的是`f[i][v-weight[i]]`。
> 因为，v>v-weight[i]，第i次循环中，执行背包容量为v时，容量为v-weight[i]的背包已经计算过，即`f[v-weight[i]]`中存储的是`f[i][v-weight[i]]`。即对于01背包，按照增序枚举背包容量是不对的。但是，增序枚举背包容量会达到什么效果：它会重复的装入某个物品，而且尽可能多的，使价值最大，当然不会不超过背包容量。


> 而逆序枚举背包容量：背包中的物品至多装一次，使价值最大，当然不会不超过背包容量

#### 初始化的细节问题

- 求最优解的背包问题时，有两种问法：

> 1. 1）在不超过背包容量的情况下，最多能获得多少价值
> 2. 2）在恰好装满背包的情况下，最多能获得多少价值

> 主要的区别为是否要求恰好装满背包。但这两种问法的实现方法是在初始化的时候有所不同。

- 1) 恰好装满背包的情况：

> 使用二维数组f[i][v]存储中间状态，其中第一维表示物品，第二维表示背包容量。初始化时，除了`f[i][0] = 0`（第一列）外，其他全为负无穷。


> **原因:** 初始化f数组就是表示：在没有任何物品可以放入背包时的合法状态。对于恰好装满背包，只有背包容量为0（第一列），可以什么物品都不装就能装满，这种情况是合法情况，此时价值为0。其他`f[0][v]`（第一列）是都不能装满的，此时有容量没物品。而其他位置（除去第一行和第一列的位置），我们为了在计算中比较最大值，也要初始化为负无穷。我们从程序的角度上看，我们只允许装入背包物品的序列的起始位置是从第一列开始，这些起始位置都是合法位置，且能恰好装满的情况收益均为正值，到`f[N][V]`终止。

>  **注意:** 我们虽然是求恰好装满，还是需要枚举所有可以装入背包的物品，只要能装入，还需装入，收益有增加。只不过，由于恰好装满的物品的序列肯定是从第一列某行开始的，且之后的收益肯定是正值。对于非恰好装满的物品序列，其实位置肯定是从第一行某位置开始的，由于此时被初始化为负无穷，在和那些恰好装满物品序列带来的价值时，肯定是小的。所以，我们最后能获得最大值。

```java
	//初始化  
	for (int i = 0;i <= V;i++)  
	{  
		f[i] = MinNum;  
	}  
	f[0] = 0;//只有背包容量为0时才是合法状态，由合法状态组成的结果才是合法的  
  
	//递推  
	for (int i = 1;i <= N;i++) //枚举物品  
	{  
		for (int j = V;j >= weight[i];j--) //枚举背包容量,防越界，j下限为 weight[i]  
		{  
			f[j] = Max(f[j],f[j - weight[i]] + value[i]);  
		}  
	}  
```

- 2) 不需要把背包装满，只需要收益最大

> 使用二维数组`f[i][v]`存储中间状态，其中第一维表示物品，第二维表示背包容量。初始化时，除了`f[i][0] = 0`（第一列）外，其他全为负无穷。使用一维数组f[v]存储中间状态，维表示背包容量

**`原因：`** 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。

### 二、完全背包问题（装入的某物品数量没有限制）

> 如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样： `f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}` 这跟01背包问题一样有O(N*V)个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。

- 一个简单有效的优化 

> 完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]<=c[j]且w[i]>=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 
> 这个优化可以简单的O(N^2)地实现，一般都可以承受。另外，针对背包问题而言，比较不错的一种方法是：首先将费用大于V的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，可以O(V+N)地完成这个优化。

- 转化为01背包问题求解 

> 既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 更高效的转化方法是：把第i种物品拆成费用为c[i]*2^k、价值为w[i]*2^k的若干件物品，其中k满足c[i]*2^k<=V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。

> 但我们有更优的O(VN)的算法。（就是上面的V按顺序循环）

> 首先想想为什么1中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态`f[i][v]`是由状态`f[i-1][v-c[i]]`递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果`f[i-1][v-c[i]]`。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果`f[i][v-c[i]]`，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。

### 三、多重背包问题（物品的数量有限制）

> 这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件„„取n[i]件。


> **`方法是：`** 将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。

### 四、混合三种背包问题 （将P01、P02、P03混合起来）

### 五、二维费用的背包问题（选择一件物品要付出两个代价）

- 算法 

> 费用加了一维，只需状态也加一维即可。设`f[i][v][u]`表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就
> 是： `f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}` 
> 如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。

- 物品总个数的限制

> 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在`f[0..V][0..M]`范围内寻找答案。

### 六、分组的背包问题 

- 问题 

> 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

- 算法 

> 这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设`f[k][v]`表示前k组物品花费费用v能取得的最大权值，则有： `f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}`

- 使用一维数组的伪代码如下：

```java
for 所有的组k
     for v=V..0 
        for 所有的i属于组k 
            f[v]=max{f[v],f[v-c[i]]+w[i]} 
```

- 注意:这里的三层循环的顺序，“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。

### 七、有依赖的背包问题（主件与附件）

> 按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件„„无法用状态转移方程来表示如此多的策略。（事实上，设有n个附件，则策略有2^n+1个，为指数级。） 

> 考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于六中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。

> 再考虑可以对每组中的物品应用二中“一个简单有效的优化”。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]所有这些值时相应的最大价值`f[0..V-c[i]]`。那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为`f[k]+w[i]`。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为V-c[i]+1个物品的物品组，就可以直接应用P06的算法解决问题了。


### 八、例题及代码

#### 简单0-1背包

- 有钱money元，买n种商品，每件商品只能买一件，或者不买，商品i的花费为：w[i],价值为v[i],求 价值最大的购买方案

```java
/*
 * m: totalMoney 总共的钱数
 * n: 可选，商品种类数
 * w[i] : 第i件商品重量
 * v[i] : 第i件商品价值
 * 
 * 返回值：f[][n]
 */
public static int[][] pack(int m, int n, int w[], int v[]) {	
	int f[][] = new int[n + 1][m + 1];
	for (int i = 0; i < n + 1; i++)
		f[i][0] = 0;
	for (int j = 0; j < m + 1; j++)
		f[0][j] = 0;
	
	for (int i = 1; i < n + 1; i++) {
		for (int j = 1; j < m + 1; j++) {			
			if (w[i - 1] <= j) {
				if (f[i - 1][j] < (f[i - 1][j - w[i - 1]] + v[i - 1]))
					f[i][j] = f[i - 1][j - w[i - 1]] + v[i - 1];
				else
					f[i][j] = f[i - 1][j];
			} else
				f[i][j] = f[i - 1][j];
		}
	}
	return f;
}

public static void main(String args[]) {
	
	Scanner sc = new Scanner(System.in);

	while (sc.hasNext()) {
		int n = sc.nextInt(); //n件物品
		int golds = sc.nextInt();//总钱数
		
		int v[] = new int[n];
		int w[] = new int[n];
		
		for(int i=0;i<n;i++){
			v[i] = sc.nextInt(); //第i件商品价值
			w[i] = sc.nextInt(); //第i件商品价格
		}
		int f[][] = pack(golds,n,w,v);
      
		
		System.out.println(f[n][golds]);
	}
	sc.close();		
}
```

