---
layout: post
title:  "TCP与UDP协议知识小结"
date:  2016-03-31
categories: NetProtocol
---

传输层协议TCP、UDP比较、TCP三次握手、四次挥手、流量控制、用塞控制

---

- 目录
{:toc}

### TCP/UDP概述 

- TCP与UDP区别:

> 1. 1.TCP***面向连接***的全双工通信，***面向字节流***；UDP是无连接的，不可靠;面向报文的(封装成数据包) 
> 2. 2.TCP提供超时重发，拥塞控制，流量控制等功能，保证数据能从一端传到另一端
> 3. 3.可靠性：UDP将数据报发出去，但是并不能保证它们能到达目的地，超时重发等机制，故而传输速度很快，网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
> 4. 4.TCP首部开销20字节;UDP的首部开销小，只有8个字节
> 5. 5.UDP支持一对一，一对多，多对一和多对多的交互通信，TCP 连接只能有两个端点，只能点对点连接

- TCP特点:

> 1. 1.TCP 传送的数据被封装在 TCP 数据报中
> 2. 2.TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的)
> 3. 3.TCP 可把太长的数据块划分短一些再传送.TCP ，也可等待积累有足够多的字节后再构成报文段发送出去
> 4. 4.TCP 连接的端点不是, 不是主机的IP 地址端口协议，而是叫做套接字(socket)或插口

### TCP三次握手

> 1. 1.A 向B发送连接请求报文段，首部中的同步SYN 置 1，ACK=0初始序号 x
> 1. 2.B 的 TCP 收到连接请求报文后，发回确认，SYN 和ACK均置为 1，确认号为 x  1，自己的初始序号 y
> 1. 3.A 收到此报文段后，向 B 给出确认，其SYN置为0，ACK置为1，序号为x+1，确认号为 y  1

### TCP四次挥手



#### 三次握手，四次挥手问题

- 问1：三次握手建立连接时，发送方发送确认的必要性？

> 防止已失效的连接请求报文段突然又传到了B,因而产生错误。A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，一直延迟到连接释放以后的某个时间才到达B，本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了，这样一直等待A发来数据，B的许多资源就这样白白浪费了。

- 问2：为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？

> 假想网络是不可靠的，无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而`重发FIN报文`，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。


- TCP的半关闭：（TCP双工的）

> TCP提供了连接的一端在关闭它的发送后，还能接收来自另一端数据的能力，这就是TCP的半关闭。如：客户端发送FIN，另一端发送对这个FIN的ACK报文段，当收到半关闭的一端在完成它的数据传送后，才发送FIN关闭这个方向的连接，客户端再对这个FIN确认，这个连接才彻底关闭。    

- TCP三次握手的攻击：SYN FLOOD

> 当客户端和服务器在网络中使用TCP协议发起会话时，在服务器内存中会开辟一小块缓冲区来处理会话过程中消息的“握手”交换。会话建立数据包包含一个SYN片段，用于标识消息交换中的序列号。而SYN FLOOD试图摧毁这一过程。攻击者快速发送一连串连接请求，之后并不响应服务器发送回来的应答，造成三次握手无法完成，在服务器上留下半打开的连接，分配给他们的缓存也被保留下来，使其他程序不能使用服务器。尽管缓冲区中的数据包在没有应答超过一段时间（通常3min）就会被丢弃，但大量虚假请求的后果是用于建立会话的合法请求难以建立。 
> 解决SYN_FLOOD攻击方案：

> 1. 第一种是缩短SYN Timeout时间，但是，对大量连续攻击无效
> 2. 第二种方法是设置SYN Cookie，给每一个请求连接的IP地址分配一个Cookie  修改IP报文

### TCP机制分析

#### 序列号&确认号

> 序列号&确认号(32bit，在TCP首部中）: TCP使用序列号、确认和重传等技术保证传输的可靠性,顺序。

> 1. ① TCP协议是面向字节的。TCP 将所要传送的报文看成是字节组成的数据流，并使每一个字节对应于一个序号。
> 2. ② 发送报文中首部序号字段数值：表示该报文段中的数据部分的第一个字节的序号
> 3. ③ 接收端返回的确认号，是已收到的数据的最高序号加 1。因此确认号表示接收端希望下次收到的数据中的第一个数据字节的序号
> 4. ④ 顺序号的最大值为  232 -1 。当数据过大，顺序号超过此数，则顺序号对232 取模

#### TCP滑动窗口机制

> TCP 连接的每一端都必须设有两个窗口：一个发送窗口和一个接收窗口
> 滑动窗口机制使得TCP能有效地使用网络资源。通过改变窗口的大小和通告窗口，TCP可以对流量进行一定的控制。

> 发送窗口（缓存）存放：

> 1. 1.发送应用程序传送给发送方 TCP 准备发送的数据
> 2. 2.TCP 已发送出但尚未收到确认的数据

> 接收窗口 缓存存放：

> 1. 1.按序到达的、但尚未被接收应用程序读取的数据；
> 2. 2.不按序到达的数据

#### TCP可靠性分析

> 1. ① 当TCP发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能记时收到一个确认，它　就重发这个报文段
> 2. ② TCP将保持它首部和数据的检验和。这是一个端到端的检验和，数据在传输过程中的任何变化或差错，TCP将丢弃这个报文段和不确认收到这个报文段
> 3. ③ TCP将对收到的(失序的)数据进行排序，将收到的数据以正确的顺序交给应用层，并丢弃重复的数据
> 4. ④ TCP还能提供流量控制，TCP连接的每一方都有固定大小的缓冲空间（大小可变的滑动窗口，窗口大小的是字节，TCP首部窗口字段写入的数值就是当前给对方发送窗口数值的上限，发送窗口的建立由双方决定，通信过程中，接受端可根据自己的资源情况，随时动态的调整对方发送窗口的上限值）。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出

### TCP用塞控制

> 数据过多而超过网络的容量时，导致拥塞的发生。一方面数据的延迟严重，另外路由器由于超载而丢弃数据，这些都会使得发送端重传更多的报文，更多的报文进入到网络中又加剧网络拥塞的状况。最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，拥塞窗口(cwnd)初始化为1个最大报文段大小(MSS)，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。

#### 慢开始&拥塞避免

> 慢开始（慢启动）

> 1. ***加法增大***：不出现拥塞时采用加法增大(+最大报文段值)的方法来逐步增大拥塞窗口
> 2. ***乘法减小***：出现拥塞时采用乘法减小(*0.5下降得很快)的方法来迅速缩小拥塞窗

> 拥塞避免
> 当拥塞窗口(cwnd)增长到慢启动门限值(ssthresh)时，就改为执行拥塞避免算法拥塞窗口按按线性规律增长，T乘MSS(每经过一个往返时延,增加一个MSS值)拥塞避免，不能完全避免拥塞，按线性规律增长，使网络不容易出现拥塞
![TCP1](/images/tcp1.png)

#### TCP快重传&快恢复
> TCP为每个发送报文段安排了一个定时器,并设定一个溢出时间，如果在定时器溢出时还未收到确认信号，发送端则重新发送数据 

- 快重传:发送端只要一连收到三个重复的 ACK 即可断定有分组丢失了，就应立即重传,而不必继续等待为该报文段设置的重传计时器的超时。

>注：收放接受到，不是期望序列的报文，会连续发送上次的响应序列

- 快恢复：快速重传和快速恢复算法一般同时使用

> 快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的

> 1. 只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1发送端收到连续三个重复的 ACK 时，就重新设置慢开始门限 ssthresh为cwnd的一半与慢开始不同之处是拥塞窗口 cwnd 不是设置为 1，而是设置为 ssthresh + n  MSS。（n >= 3，是收到的重复 ACK的个数，表明有n个“老”的数据包离开了网络）。再收到重复的ACK时，拥塞窗口增加1;
> 2. 若发送窗口值还容许发送报文段，就按拥塞避免算法继续发送报文段。
> 3. 若收到了确认新的报文段的 ACK，就将 cwnd 设置为 ssthresh。原因是该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。

### S-ACK（选择性确认）

> S-ACK(Selective Acknowledgment)
 
> 问题：如果发送序列中间某个数据包丢失，TCP会通过重传最后确认的包开始的后续包，这样原先已经正确传输的包也可能重复发送，急剧降低了TCP性能

> 解决：SACK使TCP只重新发送丢失的包，不用发送后续所有的包，而且提供相应机制使接收方能告诉发送方哪些数据丢失，哪些数据重发了，哪些数据已经提前收到等。比如说序号1，2，3，5，7的数据收到了，那么普通的ACK只会确认序列号4，而SACK会把当前的5，7已经收到的信息在SACK选项里面告知对端，从而提高性能
> 缺陷：TCP报文头仅留有40字节，则仅能容纳8个边界，过多报文丢失依然需要全部重传
