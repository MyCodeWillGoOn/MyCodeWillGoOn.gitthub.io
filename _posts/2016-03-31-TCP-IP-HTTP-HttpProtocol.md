---
layout: post
title:  "HTTP协议知识小结"
date:  2016-03-31
categories: NetProtocol
---

HTTP特点、协议报文、请求方法、状态码

---

- 目录
{:toc}

### HTTP概述

> HTTP是一个属于应用层的超文本传输协议；`面向文本`的，报文中的字段都是`ASCII码串`

- 80端口；半双工{同一时刻仅一端以一个方向传输}；客户端/服务器模式；无连接；无状态

> 1. 1.客户/服务器模式。永远都是客户端发起请求，服务器回送响应
> 2. 2.简单，只需传送请求方法和路径url。方法常用的有GET、HEAD、POST
> 3. 3.无连接:每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
> 4. 4.无连接:无状态，对于事务处理没有记忆能力，同一个浏览器再发送请求给服务器的时候，他会响应，但是他不知道你就是刚才那个浏览器。意味着：如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，可用Session-cookie解决。优点是，在服务器不需要先前信息时它的应答就较快。

### HTTP报文 

##### HTTP请求报文

> HTTP请求报文三部分组成：`请求行`、`请求头`、空行、请求体`正文`

<div align=center>
![HTTP_Request](/images/httprequest.png)
</div>

```
	GET  /?a=1&b=3  HTTP/1.1
	Host:www.baidu.com
	Accept-Language: zh-cn 
	Cookie:12345678	
```

##### HTTP响应报文

> 三部分组成:`状态行`、`响应头`、空行、响应体`正文`

```
	HTTP/1.1 301 Moved Permanently 
	Location:http://www. …/index.jsp  新URL
```

### HTTP请求方法

- GET请求
- Post请求
- Head请求
> - GET与Post区别
> 1. 1.GET使用URL或Cookie传参。而POST将数据放在请求体Body中
> 2. 2.浏览器和服务器对 URL会有长度上的限制（Http协议对url长度无要求），POST请求完全没限制
> 3. 3.POST比GET安全，因为数据在地址栏上不可见

- HEAD就像GET，只不过服务端接受到HEAD请求后，只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容
- PUT:请求服务器存储一个资源，并用Request-URI作为其标识
- DELETE：请求服务器删除Request-URI所标识的资源

### HTTP状态码

##### 状态码简介

- 1xx：请求收到，继续处理

> 1. 100：Continue服务器返回此代码表示已收到请求的一部分，正在等待其余部分
> 2. 101：Switching Protocols请求已要求服务器切换协议，服务器已确认并准备切换

- 2xx：操作成功收到，分析、接受

> 1. `200`：ok服务器成功返回网页
> 2. 201：Created请求已经被实现，而且有一个新的资源已经依据请求的需要而建立
> 3. 202：Accept服务器已接受请求，但尚未处理，可能会也可能不会被执行。异步操作的场合下，不必让客户端一直保持与服务器的连接直到批处理操作全部完成,202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。

- 3xx：重定向，完成此请求必须进一步处理

> 1. `301` Moved Permanently永久的重定向
> 2. `302` Move temporarily暂时的重定向, HTTP 1.1将1.0中302拆分为：`303`和`307`

- 4xx：请求错误，请求包含一个错误语法或不能完成

> 1. `400`：Bad Request语义or请求参数有误，当前请求无法被服务器理解
> 2. `401`：Unauthorized 当前请求需要用户验证，响应必须包含一个请求资源的 WWW-Authenticate 信息头以询问用户信息
> 3. `403`：Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助
> 4. `404`：请求失败，请求所希望得到的资源未被在服务器上发现

- 5xx：服务器错误，服务器执行一个完全有效请求失败

> 1. `500`：Internal Server Error 服务器端的源代码出现错误
> 2. 501：Not Implemented 服务器不支持当前请求方法
> 3. `503`：Service Unavailable 临时的服务器维护或者过载，服务器当前无法处理请求

##### 301与302重定向的区别

> 重定向实际使用是一个响应码（`301或302或303或307`）和一个响应头location，当浏览器收到响应的时候check响应码是3xx，则会取出响应头中location对应的url，然后将该url替换浏览器地址栏并发起另一次HTTP事务。

1. 301 Moved Permanently永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。
2. 302 Move temporarily暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。
3. HTTP 1.1将1.0中302拆分为：303和307

> 1. 303(See Other)继承了HTTP 1.0中302的实现（即原请求是post，也允许自动进行重定向，结果是无论原请求是get还是post，都可以自动进行重定向），而307则继承了HTTP 1.0中302的规范（即如果原请求是post，则不允许进行自动重定向，结果是post不重定向，get可以自动重定向）。
> 2. 307 Temporary Redirect临时重定向，如果重定向307的原请求不是get或者head方法，那么浏览器一定不能自动的进行重定向，即便location有url，也应该忽略

##### 302重定向和网址劫持

> 这要从搜索引擎如何处理302转向说起。从定义来说，从网址A做一个302重定向到网址B时，主机服务器的隐含意思是网址A随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。
实际上如果搜索引擎在遇到302转向时，百分之百的都抓取目标网址B的话，就不用担心网址URL劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。为什么呢？比如说，有的时候A网址很短，但是它做了一个302重定向到B网址，而B网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A网址更加用户友好，而B网址既难看，又不用户友好。这时Google很有可能会仍然显示网址A。
由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL劫持的可能性。也就是说，一个不道德的人在他自己的网址A做一个302重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B上的内容，这种情况就叫做网址URL劫持。你辛苦所写的内容就这样被别人偷走了。

### Http1.1新特性

1. Http1.0：协议使用非持久连接，非持久连接下,一个tcp连接只传输一个Web对象
2. Http1.1：中默认持久连接(可配置为非持久)，一个连接可以传送多个http请求对象

### HttpS新特性

> HttpS (Hypertext Transfer Protocol over Secure Socket Layer)
> SSL（Secure Socket Layer，安全套接字层）：运行在TCP/IP层之上、应用层之下，为应用程序提供加密数据通道，它采用了RC4、MD5 以及RSA等加密算法HTTPS实际上就是SSL over HTTP，它使用默认端口443，而不是像HTTP那样使用端口80来和TCP/IP进行通信。HTTPS协议使用SSL在发送方把原始数据进行加密，然 后在接受方进行解密，加密和解密需要发送方和接受方通过交换共知的密钥来实现，因此，所传送的数据不容易被网络黑客截获和解密

##### Http优缺点：

> Http的缺点：

> 1. 1. 通信使用明文不加密，内容可能被窃听;(往来信息就都是加密的)
> 2. 2. 不验证通信方身份，可能遭到伪装(通过证书与服务器唯一绑定)
> ***http效率更高，https安全性更高***

